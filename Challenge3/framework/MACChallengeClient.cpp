/**
 * MACChallengeClient.cpp
 *
 *   Version: 2019-02-21
 *    Author: Jaco ter Braak & Frans van Dijk, University of Twente.
 * Copyright: University of Twente, 2015-2019
 *
 ************************************************************
 *                                                          *
 **                 DO NOT EDIT THIS FILE                  **
 ***         YOU DO NOT HAVE TO LOOK IN THIS FILE         ***
 **** IF YOU HAVE QUESTIONS PLEASE DO ASK A TA FOR HELP  ****
 *****                                                  *****
 ************************************************************
 */

#include "MACChallengeClient.h"

namespace framework {

    MACChallengeClient::MACChallengeClient(std::string serverAddress,
        int serverPort, std::string clientGroupKey) {
        if (clientGroupKey == "get-your-token-from-the-website") {
            std::cerr << "[FRAMEWORK ERROR] Please set your group token in Program.cpp" << std::endl;
            exit(EXIT_FAILURE);
        }

        host = serverAddress;
        std::ostringstream ss;
        ss << serverPort;
        port = ss.str();
        groupKey = clientGroupKey;
        sock = 0;

        this->clientConnect();

    }

    MACChallengeClient::~MACChallengeClient() {
    }

    void MACChallengeClient::clientConnect() {
        struct addrinfo hints;
        struct addrinfo *result, *rp;
        ssize_t s;

        memset(&hints, 0, sizeof(struct addrinfo));
        hints.ai_family = AF_UNSPEC; /* Allow IPv4 or IPv6 */
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_flags = 0;
        hints.ai_protocol = IPPROTO_TCP;

        s = getaddrinfo(host.c_str(), port.c_str(), &hints, &result);
        if (s != 0) {
            std::cerr << "[FRAMEWORK ERROR] getaddrinfo:" << gai_strerror(s) << std::endl;
            exit(EXIT_FAILURE);
        }

        for (rp = result; rp != NULL; rp = rp->ai_next) {
            sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
            if (sock == -1)
                continue;

            if (connect(sock, rp->ai_addr, rp->ai_addrlen) != -1)
                break; /* Success */

#ifdef _MSC_VER
            closesocket(sock);
#else
            close(sock);
#endif 
        }

        if (rp == NULL) { /* No address succeeded */
            std::cerr << "[FRAMEWORK ERROR] Could not connect" << std::endl;
            exit(EXIT_FAILURE);
        }

        freeaddrinfo(result);

        // set non-blocking socket
#ifdef _MSC_VER
        unsigned long valueEnable = 1;
        ioctlsocket(sock, FIONBIO, &valueEnable);
#else
        ssize_t x;
        x = fcntl(sock, F_GETFL, 0);
        fcntl(sock, F_SETFL, x | O_NONBLOCK);
#endif

        // expect hello message
        if (this->getControlMessageBlocking() != "REGISTER") {
            std::cerr << "[FRAMEWORK ERROR] Did not get expected hello from server" << std::endl;
            exit(EXIT_FAILURE);
        }
        this->clearControlMessage();

        // register
        this->sendControlMessage("REGISTER " + this->groupKey);

        std::string reply = getControlMessageBlocking();
        if (reply != "OK") {
            std::string reason = reply.substr(reply.find(' ') + 1);
            std::cerr << "[FRAMEWORK ERROR] Could not register with server: " << reason << std::endl;
            exit(EXIT_FAILURE);
        }
        clearControlMessage();

        this->eventLoopThread = std::thread(&MACChallengeClient::run, this);
    }

    /**
     * Sets the listening protocol
     */
    void MACChallengeClient::setListener(IMACProtocol* listener) {
        this->listener = listener;
    }

    /**
     * Requests a simulation start from the server
     */
    void MACChallengeClient::requestStart() {
        if (!simulationStarted) {
            sendControlMessage("START");
        }
    }

    /**
     * Starts the simulation
     */
    void MACChallengeClient::start() {
        if (!simulationStarted) {
            simulationStarted = true;
        }
    }

    /**
     * @return whether the simulation has been started
     */
    bool MACChallengeClient::isSimulationStarted() {
        return simulationStarted;
    }

    /**
     * @return whether the simulation has finished
     */
    bool MACChallengeClient::isSimulationFinished() {
        return simulationFinished;
    }

    void MACChallengeClient::stop() {

        // stop simulation
        simulationStarted = false;
        simulationFinished = true;

        // stop the message loop
        this->eventLoopThread.join();

        // close comms
        this->sendControlMessage("CLOSED");
        shutdown(this->sock, 1);
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
#ifdef _MSC_VER
        closesocket(this->sock);
#else
        close(this->sock);
#endif 
    }

    void MACChallengeClient::run() {
        bool stopThread = false;
        while (!stopThread && !simulationFinished) {
            std::string message = getControlMessageBlocking();
            std::vector<std::string> splitMessage = this->split(message, ' ');

            if (splitMessage.size() > 0 && splitMessage[0].find("FAIL") == 0) {
                if (splitMessage.size() > 1) {
                    std::cerr << "[SERVER MESSAGE] Failure: "
                        << message.substr(message.find(' ') + 1) << std::endl;
                }
                clearControlMessage();
                stopThread = true;
                simulationStarted = false;
                simulationFinished = true;

            }
            else if (splitMessage.size() > 0
                && splitMessage[0].find("INFO") == 0) {
                std::cerr << "[SERVER MESSAGE] Info: "
                    << message.substr(message.find(' ') + 1) << std::endl;
            }
            else if (splitMessage.size() > 0
                && splitMessage[0].find("START") == 0) {
                // start the simulation
                simulationStarted = true;
            }
            else if (splitMessage.size() > 0
                && splitMessage[0].find("TIMESLOT") == 0) {
                if (simulationStarted) {
                    TransmissionInfo transmissionInfo;
                    int queueLength = 0;
                    bool foundTransmissionInfo = false;

                    // slot was idle
                    if (splitMessage.size() == 4
                        && splitMessage[1].find("IDLE") == 0) {
                        if (!(std::stringstream(splitMessage[3]) >> queueLength)) {
                            std::cerr
                                << "[FRAMEWORK ERROR] Error parsing int queueLength. Input was: "
                                << splitMessage[3] << std::endl;
                            exit(EXIT_FAILURE);
                        }
                        transmissionInfo = listener->TimeslotAvailable(Idle, 0,
                            queueLength);
                        foundTransmissionInfo = true;
                    }

                    // slot was collision
                    if (splitMessage.size() == 4
                        && splitMessage[1].find("COLLISION") == 0) {
                        if (!(std::stringstream(splitMessage[3]) >> queueLength)) {
                            std::cerr
                                << "[FRAMEWORK ERROR] Error parsing int queueLength. Input was: "
                                << splitMessage[3] << std::endl;
                            exit(EXIT_FAILURE);
                        }
                        transmissionInfo = listener->TimeslotAvailable(Collision, 0,
                            queueLength);
                        foundTransmissionInfo = true;
                    }

                    // slot was successful
                    if (splitMessage.size() == 5
                        && splitMessage[1].find("SUCCESS") == 0) {
                        int32_t controlInformation;
                        if (!(std::stringstream(splitMessage[4]) >> queueLength)) {
                            std::cerr
                                << "[FRAMEWORK ERROR] Error parsing int queueLength. Input was: "
                                << splitMessage[4] << std::endl;
                            exit(EXIT_FAILURE);
                        }
                        if (!(std::stringstream(splitMessage[2])
                            >> controlInformation)) {
                            std::cerr
                                << "[FRAMEWORK ERROR] Error parsing int controlInformation. Input was: "
                                << splitMessage[2] << std::endl;
                            exit(EXIT_FAILURE);
                        }
                        transmissionInfo = listener->TimeslotAvailable(Success,
                            controlInformation, queueLength);
                        foundTransmissionInfo = true;
                    }

                    // got strategy from protocol, send it back to server
                    if (foundTransmissionInfo) {
                        if (transmissionInfo.transmissionType == Data) {
                            if (queueLength <= 0) {
                                std::cerr
                                    << "[FRAMEWORK ERROR] Cannot transmit data without packets in the queue." << std::endl;
                                exit(EXIT_FAILURE);
                            }
                            this->sendControlMessage(
                                "TRANSMIT "
                                + std::to_string(transmissionInfo.controlInformation)
                                + " DATA");
                        }
                        if (transmissionInfo.transmissionType == NoData) {
                            sendControlMessage(
                                "TRANSMIT "
                                + std::to_string(transmissionInfo.controlInformation)
                                + " NO_DATA");
                        }
                        if (transmissionInfo.transmissionType == Silent) {
                            sendControlMessage("TRANSMIT 0 SILENT");
                        }
                    }
                }
            }
            else if (splitMessage.size() > 0
                && (splitMessage[0].find("FINISH") == 0
                    || splitMessage[0].find("CLOSED") == 0)) {
                simulationStarted = false;
                simulationFinished = true;

                if (splitMessage.size() > 1) {
                    std::cerr << "[SERVER MESSAGE] Connection closed: "
                        << message.substr(message.find(' ') + 1) << std::endl;
                }
            }

            clearControlMessage();

            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }
    }

    std::string MACChallengeClient::getControlMessageBlocking() {
        std::string message = "";
        while (message == "") {
            message = this->getControlMessage();
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }

        return message;
    }

    std::string MACChallengeClient::getControlMessage() {
        char socketBuffer[BUF_SIZE];
#ifdef _MSC_VER
        ssize_t nread = recv(sock, socketBuffer, BUF_SIZE, 0);
#else
        ssize_t nread = read(sock, socketBuffer, BUF_SIZE);
#endif
        if (nread != -1) {
            socketBufferStr.append(socketBuffer, nread);
        }
        if (this->currentControlMessage == "") {
            ssize_t pos = socketBufferStr.find('\n');
            if (pos > 0) {
                std::string line = socketBufferStr.substr(0, pos);
                if (line.length() > this->protocolString.length() + 1
                    && line.substr(0, this->protocolString.length())
                    == this->protocolString) {
                    this->currentControlMessage = line.substr(
                        this->protocolString.length() + 1,
                        line.length() - (this->protocolString.length() + 1));
                    socketBufferStr = socketBufferStr.substr(pos + 1,
                        socketBufferStr.length() - (pos + 1));
                }
                else {
                    std::cerr << "[FRAMEWORK ERROR] Protocol mismatch with server" << std::endl;
                    exit(EXIT_FAILURE);
                }
            }
        }

        return this->currentControlMessage;
    }

    void MACChallengeClient::clearControlMessage() {
        this->currentControlMessage = "";
    }

    void MACChallengeClient::sendControlMessage(std::string message) {
        std::string controlMessage = this->protocolString + " " + message + "\n";
#ifdef _MSC_VER
        ssize_t nwritten = send(sock, controlMessage.c_str(), controlMessage.length(), 0);
#else
        ssize_t nwritten = write(sock, controlMessage.c_str(), controlMessage.length());
#endif
        if (nwritten != (ssize_t)controlMessage.length()) {
            std::cerr << "[FRAMEWORK ERROR] Server communication failed" << std::endl;
            exit(EXIT_FAILURE);
        }
    }

    std::vector<std::string> &MACChallengeClient::split(const std::string &s,
        char delim, std::vector<std::string> &elems) {
        std::stringstream ss(s);
        std::string item;
        while (std::getline(ss, item, delim)) {
            elems.push_back(item);
        }
        return elems;
    }

    std::vector<std::string> MACChallengeClient::split(const std::string &s,
        char delim) {
        std::vector<std::string> elems;
        split(s, delim, elems);
        return elems;
    }

} /* namespace framework */
