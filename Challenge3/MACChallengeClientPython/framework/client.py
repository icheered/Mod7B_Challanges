"""
 *                                                          *
 **                 DO NOT EDIT THIS FILE                  **
 ***         YOU DO NOT HAVE TO LOOK IN THIS FILE         ***
 **** IF YOU HAVE QUESTIONS PLEASE DO ASK A TA FOR HELP  ****
 *****                                                  *****
 ************************************************************
 """

import socket
import threading
import time
import io
import traceback

import sys

from framework.abstract import AbstractMACProtocol
from framework.transmission_info import MediumState, TransmissionType
# from framework.framework import SimulationState

class SimulationState:
    IDLE = 1
    STARTED = 2
    FINISHED = 3


class MACChallengeClient(threading.Thread):
    protocol_string = "MACCHALLENGE/2.0"  # type: str
    address = "localhost"  # type: str
    port = 8002  # type: int
    token = ""  # type: str

    current_control_message = ""  # type: str
    sock = None  # type: socket.socket
    socket_file = None  # type: io.TextIOWrapper
    stop_thread = True  # type: bool

    protocol = None  # type: AbstractMACProtocol

    def __init__(self, server_address, server_port, token, *args, **kwargs):
        """
        Constructs the client and connects to the server
        :param server_address: Challenge server address
        :type server_address: str
        :param server_port: Challenge server port
        :type server_port: int
        :param token: Group password
        :type token: str
        """
        self.address = server_address
        self.port = server_port
        self.token = token
        self.simulation_state = SimulationState.IDLE
        super().__init__(*args, **kwargs)

        self.connect()

    def get_address(self):
        """
        Get the server address used
        :return: The current server address
        :rtype: str
        """
        return self.address

    def get_simulation_state(self):
        """
        Get the current simulation state
        :return: The current simulation state
        :rtype: SimulationState
        """
        return self.simulation_state

    def is_simulation_running(self):
        """
        Check if the simulation is running
        :return: Whether the simulation has been started
        :rtype: bool
        """
        return self.simulation_state == SimulationState.STARTED

    def is_simulation_finished(self):
        """
        Check if the simulation is finished
        :return: If the simulation has finished
        :rtype: bool
        """
        return self.simulation_state == SimulationState.FINISHED

    def connect(self):
        """
        Connect to the challenge server
        :raises: InterruptedError, socket.timeout
        """
        self.sock = socket.create_connection((self.address, self.port))
        self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        self.sock.setblocking(True)
        self.socket_file = self.sock.makefile('rw')

        # Try to receive server hello
        if self.get_control_message() != "REGISTER":
            raise ConnectionError("Did not get expected hello from server")
        self.clear_control_message()

        # Register with server
        self.send_control_message("REGISTER {}".format(self.token))
        reply = self.get_control_message()
        if reply != "OK":
            raise ConnectionError("Could not register with server: {}".format(" ".join(reply.split(" ")[1:])))
        self.clear_control_message()

        # Start handling messages
        self.start()

    def set_protocol(self, protocol):
        """
        Set the protocol used for the Medium Access Control
        :param protocol: The implementation of the protocol
        :type protocol: AbstractMACProtocol
        :return:
        """
        self.protocol = protocol

    def request_start(self):
        """
        Requests a simulation start from the server
        """
        if self.simulation_state == SimulationState.IDLE:
            self.send_control_message("START")

    def stop_simulation(self):
        """
        Stops the client, and disconnects it from the server.
        """
        # Stop the simulation
        self.simulation_state = SimulationState.FINISHED

        # Stop the message event loop
        self.stop_thread = False
        self.join()

        # Close the socket
        self.send_control_message("CLOSED")
        time.sleep(1)
        self.socket_file.flush()
        try:
            self.sock.close()
        except Exception:
            traceback.print_exc()

    def run(self):
        """
        Handle communication between the server and the protocol implementation
        """
        self.stop_thread = False
        while not self.stop_thread and not self.is_simulation_finished():
            try:
                msg = self.get_control_message()
                msg_parts = msg.split(" ")

                if msg_parts[0] == "FAIL":
                    if len(msg_parts) > 1:
                        print("[SERVER MESSAGE] Failure: {}".format(" ".join(msg_parts[1:])), file=sys.stderr)
                    self.clear_control_message()
                    self.stop_thread = True
                    self.simulation_state = SimulationState.FINISHED

                elif msg_parts[0] == "INFO":
                    print("[SERVER MESSAGE] Info: {}".format(" ".join(msg_parts[1:])), file=sys.stderr)

                elif msg_parts[0] == "START":
                    # Start the simulation
                    self.simulation_state = SimulationState.STARTED

                elif msg_parts[0] == "TIMESLOT":
                    if self.is_simulation_running():
                        transmission_info = None  # type: tuple(TransmissionType, int) or TransmissionType
                        queue_length = 0

                        # Slot was idle
                        if len(msg_parts) == 4 and msg_parts[1] == "IDLE":
                            queue_length = int(msg_parts[3])
                            transmission_info = self.protocol.timeslot_available(MediumState.IDLE,
                                                                                 0,  # Control info
                                                                                 queue_length)  # Queue length

                        # Slot was collision
                        if len(msg_parts) == 4 and msg_parts[1] == "COLLISION":
                            queue_length = int(msg_parts[3])
                            transmission_info = self.protocol.timeslot_available(MediumState.COLLISION,
                                                                                 0,  # Control info
                                                                                 queue_length)  # Queue length

                        # Slot was successful
                        if len(msg_parts) == 5 and msg_parts[1] == "SUCCESS":
                            queue_length = int(msg_parts[4])
                            transmission_info = self.protocol.timeslot_available(MediumState.SUCCESS,
                                                                                 int(msg_parts[2]),  # Control info
                                                                                 queue_length)  # Queue length

                        # Got strategy from protocol, send it back to server
                        if transmission_info is not None:
                            if type(transmission_info) not in [int, tuple]:
                                print("[FRAMEWORK] Warning: Your timeslot_available function returned an unexpected "
                                      "value and it will be ignored.")
                                continue

                            if type(transmission_info) == int:
                                transmission_info = transmission_info, 0
                            if transmission_info[0] == TransmissionType.DATA:
                                if queue_length <= 0:
                                    raise ValueError("Cannot transmit data without any packets in the queue.")
                                data = transmission_info[1]
                                self.send_control_message("TRANSMIT {} DATA".format(data))

                            elif transmission_info[0] == TransmissionType.NO_DATA:
                                data = transmission_info[1]
                                self.send_control_message("TRANSMIT {} NO_DATA".format(data))

                            elif transmission_info[0] == TransmissionType.SILENT:
                                self.send_control_message("TRANSMIT 0 SILENT")

                elif msg_parts[0] == "CLOSED":
                    self.simulation_state = SimulationState.FINISHED
                    print("[FRAMEWORK] Simulation aborted!", file=sys.stderr)
                    if len(msg_parts) > 1:
                        print("[FRAMEWORK] Reason: {}".format(" ".join(msg_parts[1:])))

                elif msg_parts[0] == "FINISH":
                    self.simulation_state = SimulationState.FINISHED
                    print("[FRAMEWORK] Simulation finished! Check your performance on the server web interface.")

                else:
                    print("[FRAMEWORK] Warning: Unknown control message - {}".format(msg), file=sys.stderr)

                self.clear_control_message()

            except socket.error or socket.timeout:
                print("[FRAMEWORK] Error while processing control message.")
                traceback.print_exc()
                self.stop_thread = True

            try:
                time.sleep(0.01)
            except InterruptedError or KeyboardInterrupt:
                self.stop_thread = True

    def clear_control_message(self):
        """
        Removes the first message from the queue.
        Call this when you have processed a message.
        """
        self.current_control_message = None

    def get_control_message(self):
        """
        Wait for and read a control message from the server
        :return: The message
        :rtype: str
        :raises: ConnectionError
        """
        msg = ''
        while msg == '':
            msg = self.socket_file.readline()
            msg_parts = msg.split(" ")
            if msg != '':
                if msg_parts[0] == self.protocol_string:
                    return " ".join(msg_parts[1:]).strip()
                else:
                    raise ConnectionError("Protocol mismatch with server. (Server={}, Client={})".format(msg_parts[0], self.protocol_string))

    def send_control_message(self, msg):
        """
        Sends a message to the server. Return if it was successful
        :param msg: The message to send
        :type msg: str
        :return: If the message was sent
        :rtype: bool
        """
        try:
            self.socket_file.write("{} {}\n".format(self.protocol_string, msg))
            self.socket_file.flush()
            return True
        except socket.error as e:
            print("[FRAMEWORK] Error sending message to challenge server. {}: {}".format(type(e).__name__, e), file=sys.stderr)
            return False
