"""
 *                                                          *
 **                 DO NOT EDIT THIS FILE                  **
 ***         YOU DO NOT HAVE TO LOOK IN THIS FILE         ***
 **** IF YOU HAVE QUESTIONS PLEASE DO ASK A TA FOR HELP  ****
 *****                                                  *****
 ************************************************************
 """

import signal
import sys
import threading
import time
import traceback
import os

from framework.client import MACChallengeClient
from my_protocol.my_protocol import MyProtocol


class Program(threading.Thread):
    # Change to your group token (get it from the web interface)
    token = "get-token-from-web-interface"

    # Change to your protocol implementation (don't forget to import it first!)
    multiple_access_protocol = MyProtocol

    # Challenge server address
    server_address = "networkingchallenges.ewi.utwente.nl"

    # Challenge server port
    server_port = 8003

    # Framework client
    client = None

    def __init__(self, token=None, protocol=None, server=None, port=None):
        super().__init__()
        if token is not None:
            self.token = token
        if protocol is not None:
            self.multiple_access_protocol = protocol
        if server is not None:
            self.server_address = server
        if port is not None:
            self.server_port = port

    def start_framework(self):
        try:
            self.client = MACChallengeClient(server_address=self.server_address, server_port=self.server_port,
                                             token=self.token)
        except ConnectionError as e:
            print("[FRAMEWORK] Error: Could not start client!", file=sys.stderr)
            print("[FRAMEWORK] Reason: {}: {}".format(type(e).__name__, e), file=sys.stderr)
            return

        # Initialize the protocol used
        protocol = self.create_protocol()
        self.client.set_protocol(protocol)

        # Wait to start simulation
        print("[FRAMEWORK] Press Enter to start simulation...")
        print("[FRAMEWORK] (Simulation will also be started automatically "
              "if another client in the group issues the start command)")

        start = False
        self_start = InputStart()
        t = threading.Thread(target=get_input, args=(self_start,))
        t.start()

        while not self.client.is_simulation_running() and not self.client.is_simulation_finished():
            if not start and self_start.input:
                # Request start as sender
                self.client.request_start()
                start = True
            time.sleep(0.01)

        print("[FRAMEWORK] Simulation started!")

        while not self.client.is_simulation_finished():
            try:
                time.sleep(1)
            except InterruptedError:
                break

        os._exit(0)  # nasty exit method. Used instead of sys.exit so that the input listen thread is killed instead of waiting for it.

    def create_protocol(self):
        """
        Create an instance of the protocol
        :return: A protocol instance
        :rtype: AbstractRDTProtocol
        """
        try:
            return self.multiple_access_protocol()
        except Exception:
            traceback.print_exc()
        return None

# hacky solution to pass reference to same bool across threads...
class InputStart:
    def __init__(self):
        self.input = False

def get_input( input_found ):
    input() # just wait for input here...
    input_found.input = True

class SimulationState:
    IDLE = 1
    STARTED = 2
    FINISHED = 3
