/**
 * DRDTChallengeClient.cpp
 *
 *   Version: 2018-02-14
 *    Author: Jaco ter Braak & Frans van Dijk, University of Twente.
 * Copyright: University of Twente, 2015-2019
 *
 ************************************************************
 *                                                          *
 **                 DO NOT EDIT THIS FILE                  **
 ***         YOU DO NOT HAVE TO LOOK IN THIS FILE         ***
 **** IF YOU HAVE QUESTIONS PLEASE DO ASK A TA FOR HELP  ****
 *****                                                  *****
 ************************************************************
 */

#include "DRDTChallengeClient.h"

#include <chrono>
#include <thread>

namespace framework {

    DRDTChallengeClient::DRDTChallengeClient(std::string serverAddress,
        int32_t serverPort, std::string clientGroupKey) {
        if (clientGroupKey == "get-your-key-from-the-website") {
            std::cerr << "Please set your group key in Program.cpp" << std::endl;
            exit(EXIT_FAILURE);
        }

        host = serverAddress;
        std::ostringstream ss;
        ss << serverPort;
        port = ss.str();
        groupKey = clientGroupKey;
        sock = 0;

        this->clientConnect();
    }

    DRDTChallengeClient::~DRDTChallengeClient() {
    }

    void DRDTChallengeClient::clientConnect() {
        struct addrinfo hints;
        struct addrinfo *result, *rp;
        ssize_t s;

        memset(&hints, 0, sizeof(struct addrinfo));
        hints.ai_family = AF_UNSPEC; /* Allow IPv4 or IPv6 */
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_flags = 0;
        hints.ai_protocol = IPPROTO_TCP;

        s = getaddrinfo(host.c_str(), port.c_str(), &hints, &result);
        if (s != 0) {
            std::cerr << "getaddrinfo:" << gai_strerror(s) << std::endl;
            exit(EXIT_FAILURE);
        }

        for (rp = result; rp != NULL; rp = rp->ai_next) {
            sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
            if (sock == -1)
                continue;

            if (connect(sock, rp->ai_addr, rp->ai_addrlen) != -1)
                break; /* Success */

#ifdef _MSC_VER
            closesocket(sock);
#else
            close(sock);
#endif
        }

        if (rp == NULL) { /* No address succeeded */
            std::cerr << "Could not connect" << std::endl;
            exit(EXIT_FAILURE);
        }

        freeaddrinfo(result);

        // set non-blocking socket
#ifdef _MSC_VER
        unsigned long valueEnable = 1;
        ioctlsocket(sock, FIONBIO, &valueEnable);
#else
        ssize_t x;
        x = fcntl(sock, F_GETFL, 0);
        fcntl(sock, F_SETFL, x | O_NONBLOCK);
#endif

        // expect hello message
        if (this->getControlMessageBlocking() != "REGISTER") {
            std::cerr << "Did not get expected hello from server" << std::endl;
            exit(EXIT_FAILURE);
        }
        this->clearControlMessage();

        // register
        this->sendControlMessage("REGISTER " + this->groupKey);

        std::string reply = getControlMessageBlocking();
        if (reply != "OK") {
            std::string reason = reply.substr(reply.find(' ') + 1);
            std::cerr << "Could not register with server: " << reason << std::endl;
            exit(EXIT_FAILURE);
        }
        clearControlMessage();

        this->eventLoopThread = std::thread(&DRDTChallengeClient::run, this);
    }

    /**
     * Requests a simulation start from the server
     */
    void DRDTChallengeClient::requestStart(std::string id) {
        if (!simulationStarted) {
            isSender = true;
            sendControlMessage("START " + id);
        }
    }

    /**
     * Starts the simulation
     */
    void DRDTChallengeClient::start() {
        if (!simulationStarted) {
            simulationStarted = true;
        }
    }

    /**
     * @return whether the simulation has been started
     */
    bool DRDTChallengeClient::isSimulationStarted() {
        return simulationStarted;
    }

    /**
     * @return whether the simulation has finished
     */
    bool DRDTChallengeClient::isSimulationFinished() {
        return simulationFinished;
    }

    /**
     * @return whether the output buffer is empty
     */
    bool DRDTChallengeClient::isOutputBufferEmpty() {
        return this->outputPacketBuffer.size() == 0;
    }

    /**
     * @return the ID of the file that will be send/received
     */
    std::string DRDTChallengeClient::getFileID() {
        return this->fileID;
    }

    std::thread * DRDTChallengeClient::getEventLoop() {
        return &this->eventLoopThread;
    }

    void DRDTChallengeClient::sendChecksum(std::string type, std::string filename) {
        std::ifstream ifs(filename, std::ifstream::binary);

        if (!ifs.good()) {
            std::cout << "File not found! Please verify that you have your files in the correct place." << std::endl;
            std::cout << "Missing file: " << filename << std::endl;
            exit(EXIT_FAILURE);
        }

        std::string fileContents((std::istreambuf_iterator<char>(ifs)),
            (std::istreambuf_iterator<char>()));
        std::string crcData = this->challenge + fileContents;

        uint32_t crc = ::crc32_1byte(crcData.c_str(), crcData.length(), 0);
        this->sendControlMessage("CHECKSUM " + type + " " + std::to_string(crc));
    }

    void DRDTChallengeClient::stop() {
        // stop simulation
        simulationStarted = false;
        simulationFinished = true;

        // stop the message loop. For the sender this is already joined....
        if(!isSender){
            this->eventLoopThread.join();
        }        
        
        // close comms        
        // std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // Why was this here?
        this->sendControlMessage("CLOSED");
        shutdown(this->sock, 1);
#ifdef _MSC_VER
        closesocket(this->sock);
#else
        close(this->sock);
#endif
    }

    void DRDTChallengeClient::run() {
        bool stopThread = false;
        while (!stopThread && !simulationFinished) {
            std::string message = getControlMessageBlocking();
            std::vector<std::string> splitMessage = this->split(message, ' ');

            if (splitMessage.size() > 0 && splitMessage.at(0).find("FAIL") == 0) {
                if (splitMessage.size() > 1) {
                    std::cout << "Failure: "
                        << message.substr(message.find(' ') + 1) << std::endl;
                }
                clearControlMessage();
                stopThread = true;
                simulationStarted = false;
                simulationFinished = true;

            }
            else if (splitMessage.size() > 1 && splitMessage.at(0).find("START") == 0) {
                // start the simulation
                this->fileID = splitMessage.at(1);
                this->challenge = base64_decode(splitMessage.at(2));
                this->start();

                // upload file checksum
                if (isSender) {
                    sendChecksum("IN", "rdtcInput" + fileID + ".png");
                }

            }
            else if (splitMessage.size() > 0
                && splitMessage.at(0).find("SLOT") == 0) {
                // We got offered a slot by the server to send a packet in.
                bool transmitted = false;
                if (simulationStarted) {
                    if (this->outputPacketBuffer.size() > 0) {
                        outputPacketBufferLock.lock();
                        if (this->outputPacketBuffer.size() > 0) {
                            // If there are packets available, send one.
                            // Note: only lowest 8-bit of integers is used.
                            std::vector<int32_t> packetContentsInIntegers =
                                this->outputPacketBuffer.front();
                            this->outputPacketBuffer.pop_front();
                            this->sendControlMessage(
                                "TRANSMIT "
                                + base64_encode(packetContentsInIntegers));
                            transmitted = true;
                        }
                        outputPacketBufferLock.unlock();
                    }
                }

                if (!transmitted) {
                    this->sendControlMessage("NOTRANSMIT");
                }

            }
            else if (splitMessage.size() > 0
                && splitMessage.at(0).find("PACKET") == 0) {
                // We received a packet from the server
                if (simulationStarted) {
                    std::vector<int32_t> packetContentsInIntegers;
                    if (splitMessage.size() > 1) {
                        // convert base64 string to bytes
                        std::string packetContents = base64_decode(
                            splitMessage.at(1));
                        // convert 8-bit bytes to 32-bit integers
                        packetContentsInIntegers = std::vector<int32_t>(
                            packetContents.length());
                        for (uint32_t i = 0; i < packetContents.length(); i++) {

                            packetContentsInIntegers[i] = (packetContents[i]
                                & 0x000000ff);
                        }

                    }
                    else {
                        packetContentsInIntegers = std::vector<int32_t>(0);
                    }

                    this->inputPacketBufferLock.lock();
                    this->inputPacketBuffer.push_back(packetContentsInIntegers);
                    this->inputPacketBufferLock.unlock();
                }

            }
            else if (message.find("CLOSED") == 0) {
                simulationStarted = false;
                simulationFinished = true;

                std::cout << "Simulation aborted!" << std::endl;
                if (splitMessage.size() > 1) {
                    std::cerr << "Reason: " << message.substr(message.find(' ') + 1)
                        << std::endl;
                }
            }
            else if (message.find("FINISH") == 0) {
                simulationStarted = false;
                simulationFinished = true;
                
                std::cout
                    << "Simulation finished! Check your performance on the server web interface."
                    << std::endl;
            }

            clearControlMessage();

        }
    }

    bool DRDTChallengeClient::receivePacket(std::vector<int32_t> *packet) {
        if (this->inputPacketBuffer.size() > 0) {
            this->inputPacketBufferLock.lock();
            if (this->inputPacketBuffer.size() > 0) {
                std::vector<int32_t> pck = this->inputPacketBuffer.front();
                this->inputPacketBuffer.pop_front();
                *packet = pck;
                this->inputPacketBufferLock.unlock();
                return true;
            }
            this->inputPacketBufferLock.unlock();
        }
        return false;
    }

    void DRDTChallengeClient::sendPacket(std::vector<int32_t> packet) {
        this->outputPacketBufferLock.lock();
        this->outputPacketBuffer.push_back(packet);
        this->outputPacketBufferLock.unlock();
    }

    std::string DRDTChallengeClient::getControlMessageBlocking() {
        std::string message = "";
        while (message == "") {
            message = this->getControlMessage();
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }

        return message;
    }

    std::string DRDTChallengeClient::getControlMessage() {
        char socketBuffer[BUF_SIZE];
#ifdef _MSC_VER
        ssize_t nread = recv(sock, socketBuffer, BUF_SIZE, 0);
#else
        ssize_t nread = read(sock, socketBuffer, BUF_SIZE);
#endif
        if (nread != -1) {
            socketBufferStr.append(socketBuffer, nread);
        }
        if (this->currentControlMessage == "") {
            ssize_t pos = socketBufferStr.find('\n');
            if (pos > 0) {
                std::string line = socketBufferStr.substr(0, pos);
                if (line.length() > this->protocolString.length() + 1
                    && line.substr(0, this->protocolString.length())
                    == this->protocolString) {
                    this->currentControlMessage = line.substr(
                        this->protocolString.length() + 1,
                        line.length() - (this->protocolString.length() + 1));
                    socketBufferStr = socketBufferStr.substr(pos + 1,
                        socketBufferStr.length() - (pos + 1));
                }
                else {
                    std::cerr << "Protocol mismatch with server" << std::endl;
                    exit(EXIT_FAILURE);
                }
            }
        }

        return this->currentControlMessage;
    }

    void DRDTChallengeClient::clearControlMessage() {
        this->currentControlMessage = "";
    }

    void DRDTChallengeClient::sendControlMessage(std::string message) {
        std::string controlMessage = this->protocolString + " " + message + "\n";
#ifdef _MSC_VER
        ssize_t nwritten = send(sock, controlMessage.c_str(), controlMessage.length(), 0);
#else
        ssize_t nwritten = write(sock, controlMessage.c_str(), controlMessage.length());
#endif
        if (nwritten != (ssize_t)controlMessage.length()) {
            std::cerr << "Write failed" << std::endl;
            exit(EXIT_FAILURE);
        }
    }

    std::vector<std::string> &DRDTChallengeClient::split(const std::string &s,
        char delim, std::vector<std::string> &elems) {
        std::stringstream ss(s);
        std::string item;
        while (std::getline(ss, item, delim)) {
            elems.push_back(item);
        }
        return elems;
    }

    std::vector<std::string> DRDTChallengeClient::split(const std::string &s,
        char delim) {
        std::vector<std::string> elems;
        split(s, delim, elems);
        return elems;
    }
} /* namespace framework */
